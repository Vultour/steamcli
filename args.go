package main

import (
	"errors"
	"fmt"
	"os"
	"strconv"

	"github.com/akamensky/argparse"
	log "github.com/sirupsen/logrus"
)

// Arguments contains data for parsed command line arguments
type Arguments struct { // .
	Parser *argparse.Parser

	Verbose *bool
	Debug   *bool
	JSONLog *bool

	IDs           *[]string
	CacheFile     *string
	CacheParallel *int
	NoAutoCache   *bool

	Games struct { // .games
		Command   *argparse.Command
		FetchTags *bool

		TagsOnly *bool
		Tag      *[]string
		Common   *bool
		And      *bool
		Invalid  *bool
	}

	Cache struct { // .cache
		Command *argparse.Command

		Games struct { // .cache.games
			Command          *argparse.Command
			PurgeInvalid     *argparse.Command // .cache.games.purge-invalid
			PurgeMissingTags *argparse.Command // .cache.games.purge-misssing-tags
			Info             *argparse.Command

			FetchTags *bool

			Print struct { // .cache.games.print
				Command *argparse.Command

				Tag     *[]string
				AppID   *[]string
				And     *bool
				Invalid *bool

				// Autogenerated
				AppIDInt []int
			}

			Delete struct { // .cache.games.delete
				Command *argparse.Command

				AppID *[]string
				Name  *[]string

				// Autogenerated
				AppIDInt []int
			}
		}
	}
}

// Arguments contains data for the top-level command
type apArguments struct {
	Parser *argparse.Parser
	Games  GamesArguments
	Cache  CacheArguments

	Verbose *bool
	Debug   *bool
	JSONLog *bool

	IDs           *[]string
	CacheFile     *string
	CacheParallel *int
	NoAutoCache   *bool
}

// GamesArguments contains data for the .games subcommand
type GamesArguments struct {
	Command   *argparse.Command
	FetchTags *bool

	Common  *bool
	TagsAnd *bool
	TagsOr  *bool
}

// CacheArguments contains data for the .cache subcommand
type CacheArguments struct {
	Command *argparse.Command
	Games   CacheGamesArguments
}

// CacheGamesArguments contains data for the .cache.games subcommand
type CacheGamesArguments struct {
	Command          *argparse.Command
	PurgeInvalid     *argparse.Command
	PurgeMissingTags *argparse.Command
	Print            CacheGamesPrintArguments

	FetchTags *bool
}

// CacheGamesPrintArguments contains data for the .cache.games.print subcommand
type CacheGamesPrintArguments struct {
	Command *argparse.Command
	And     *bool
	Or      *bool
	Tag     *[]string
	Invalid *bool
}

// ParseArgs parses the command line arguments
func ParseArgs() *Arguments {
	ap := &Arguments{}

	// Core arguments
	ap.Parser = argparse.NewParser(
		"steamcli",
		"Utility for combining, filtering, and printing community profile data",
	)
	ap.Verbose = ap.Parser.Flag(
		"v", "verbose",
		&argparse.Options{Help: "Increase logging verbosity"},
	)
	ap.Debug = ap.Parser.Flag(
		"", "debug",
		&argparse.Options{Help: "Increase logging verbosity even more"},
	)
	ap.JSONLog = ap.Parser.Flag(
		"", "json-log",
		&argparse.Options{Help: "Use JSON as logging format"},
	)
	ap.IDs = ap.Parser.List(
		"i", "id",
		&argparse.Options{
			Help: "A steam ID (64bit, STEAM_X:Y:Z, or community ID)",
		},
	)
	ap.CacheFile = ap.Parser.String(
		"", "cache-file",
		&argparse.Options{
			Help: "File to be used for the game cache",
		},
	)
	ap.CacheParallel = ap.Parser.Int(
		"", "cache-parallel",
		&argparse.Options{
			Help:    "How many games to fetch in parallel when getting details",
			Default: 1,
		},
	)
	ap.NoAutoCache = ap.Parser.Flag(
		"n", "no-auto-cache",
		&argparse.Options{
			Help: "Don't retrieve details for non-cached games",
		},
	)

	// .games
	ap.Games.Command = ap.Parser.NewCommand(
		"games", "Interact with the game library",
	)
	ap.Games.FetchTags = ap.Games.Command.Flag(
		"f", "fetch-tags",
		&argparse.Options{
			Help: "Fetch game tags, requires additional HTTP request per game",
		},
	)
	ap.Games.TagsOnly = ap.Games.Command.Flag(
		"", "tags-only",
		&argparse.Options{
			Help: "Show only tags associated with games, not games themselves",
		},
	)
	ap.Games.Common = ap.Games.Command.Flag(
		"c", "common",
		&argparse.Options{
			Help: "Show only games common across all accounts",
		},
	)
	ap.Games.Tag = ap.Games.Command.List(
		"t", "tag",
		&argparse.Options{
			Help: "Only select games matching this tag (can be used more than once)",
		},
	)
	ap.Games.And = ap.Games.Command.Flag(
		"a", "and",
		&argparse.Options{
			Help: "Show games that match all of the specified tags, default is _any_ of the tags",
		},
	)
	ap.Games.Invalid = ap.Games.Command.Flag(
		"", "invalid",
		&argparse.Options{
			Help: "Also show invalid games (no store page for the App ID)",
		},
	)

	// .cache
	ap.Cache.Command = ap.Parser.NewCommand(
		"cache",
		"Manipulate the steamcli cache",
	)

	// .cache.games
	ap.Cache.Games.Command = ap.Cache.Command.NewCommand(
		"games",
		"Manipulate the steamcli game cache",
	)
	ap.Cache.Games.FetchTags = ap.Cache.Games.Command.Flag(
		"", "fetch-tags",
		&argparse.Options{Help: "Fetch missing game tags"},
	)

	// .cache.games.purge-invalid
	ap.Cache.Games.PurgeInvalid = ap.Cache.Games.Command.NewCommand(
		"purge-invalid",
		"Purge invalid games from the cache",
	)

	// .cache.games.purge-missing-tags
	ap.Cache.Games.PurgeMissingTags = ap.Cache.Games.Command.NewCommand(
		"purge-missing-tags",
		"Purge games with missing tags from the cache",
	)

	// .cache.games.info
	ap.Cache.Games.Info = ap.Cache.Games.Command.NewCommand(
		"info",
		"Show information about the game cache",
	)

	// .cache.games.print
	ap.Cache.Games.Print.Command = ap.Cache.Games.Command.NewCommand(
		"print",
		"Print contents of the game cache",
	)
	ap.Cache.Games.Print.Tag = ap.Cache.Games.Print.Command.List(
		"", "tag",
		&argparse.Options{
			Help: "Filter by game tag (can be specified more than once)",
		},
	)
	ap.Cache.Games.Print.AppID = ap.Cache.Games.Print.Command.List(
		"", "appid",
		&argparse.Options{
			Help: "Filter by App ID (can be specified more than once)",
		},
	)
	ap.Cache.Games.Print.And = ap.Cache.Games.Print.Command.Flag(
		"", "and",
		&argparse.Options{
			Help: "Select games matching all specified tags (default is _any_ tag)",
		},
	)
	ap.Cache.Games.Print.Invalid = ap.Cache.Games.Print.Command.Flag(
		"", "invalid",
		&argparse.Options{
			Help: "Select invalid games as well (AppIDs associated with account without a store page)",
		},
	)

	// .cache.games.delete
	ap.Cache.Games.Delete.Command = ap.Cache.Games.Command.NewCommand(
		"delete",
		"Delete entries from the game cache",
	)
	ap.Cache.Games.Delete.AppID = ap.Cache.Games.Delete.Command.List(
		"", "appid",
		&argparse.Options{
			Help: "A game App ID (can be specified more than once)",
		},
	)
	ap.Cache.Games.Delete.Name = ap.Cache.Games.Delete.Command.List(
		"", "name",
		&argparse.Options{
			Help: "A game name (exact match only, can be specified more than once)",
		},
	)

	// Parse
	if err := ap.Parser.Parse(os.Args); err != nil {
		fmt.Print(ap.Parser.Usage(err))
		os.Exit(1)
	}
	if err := validateArgs(ap); err != nil {
		fmt.Print(ap.Parser.Usage(err))
		os.Exit(2)
	}
	if err := complete(ap); err != nil {
		fmt.Print(ap.Parser.Usage(err))
	}

	return ap
}

func validateArgs(a *Arguments) error {
	if a.Games.Command.Happened() {
		if len(*a.IDs) < 1 {
			return errors.New("No Steam IDs specified")
		}
	}

	if a.Cache.Command.Happened() {
		if a.Cache.Games.Command.Happened() {
			// TODO: Any validation here?
		}
	}

	log.SetLevel(log.WarnLevel)
	if *a.Verbose {
		log.SetLevel(log.InfoLevel)
	}
	if *a.Debug {
		log.SetLevel(log.DebugLevel)
	}

	if *a.JSONLog {
		log.SetFormatter(&log.JSONFormatter{})
	}

	return nil
}

func complete(a *Arguments) error {
	if a.Cache.Command.Happened() {
		if a.Cache.Games.Command.Happened() {
			if a.Cache.Games.Print.Command.Happened() {
				appids, err := sliceToInt(*a.Cache.Games.Print.AppID)
				if err != nil {
					return fmt.Errorf("could not convert appid to number: %d", err)
				}
				a.Cache.Games.Print.AppIDInt = appids
			}
			if a.Cache.Games.Delete.Command.Happened() {
				appids, err := sliceToInt(*a.Cache.Games.Delete.AppID)
				if err != nil {
					return fmt.Errorf("could not convert appid to number: %d", err)
				}
				a.Cache.Games.Delete.AppIDInt = appids
			}
		}
	}
	return nil
}

func sliceToInt(source []string) ([]int, error) {
	ret := make([]int, 0, len(source))
	for _, x := range source {
		y, err := strconv.Atoi(x)
		if err != nil {
			return nil, err
		}
		ret = append(ret, y)
	}
	return ret, nil
}
